# 객체지향 프로그래밍과 디자인 패턴

## 목차
- [상속 / 구현](#상속--구현)
- [디자인 패턴 (Design Pattern)](#디자인-패턴-design-pattern)
- [프로그래밍 패러다임](#프로그래밍-패러다임)
- [설계 원칙 (SOLID)](#설계-원칙-solid)

---
#### 들어가기전 알아야할 상식

### 상속 (Inheritance)
- 자식 클래스가 부모 클래스의 메서드를 상속받아 **추가 및 확장**하는 개념.
- **재사용성 향상 및 코드 중복 최소화**.
- 사용 대상: 일반 클래스, 추상 클래스(`abstract class`)

### 구현 (Implementation)
- 부모 **인터페이스**를 자식 클래스에서 **무조건 재정의(override)** 해야 함.
- 사용 대상: `interface`

---

## 디자인 패턴 (Design Pattern)

### 1. Proxy 패턴
- 대상 객체(Subject)에 접근하기 전 **접근 흐름을 가로채거나 수정/필터링**하는 계층이 존재하는 패턴.

#### 프록시 서버
- 서버와 클라이언트 사이에서 클라이언트가 **간접적으로 네트워크 서비스에 접속**할 수 있게 하는 시스템 또는 프로그램.

#### CDN (Content Delivery Network)
- 사용자와 가까운 지역에 콘텐츠를 **캐싱 및 배포**하는 서버 네트워크.
- 웹 콘텐츠 다운로드 시간을 단축함.

#### CORS (Cross-Origin Resource Sharing)
- 다른 오리진에서 리소스를 로드하지 못하게 하는 **HTTP 헤더 기반 메커니즘**.
- 예: 프론트엔드(`127.0.0.1:3000`)와 백엔드(`127.0.0.1:12010`) 포트가 다르면 CORS 에러 발생.
- **프록시 서버를 통해 요청 오리진을 백엔드 오리진으로 변환**하여 해결.

---

### 2.  MVC 패턴
- 어플리케이션을 **Model - View - Controller**로 구분하여 각 역할에 집중할 수 있게 함.
- **재사용성과 확장성**이 높음.

#### Model
- 데이터베이스, 상수, 변수 등 **애플리케이션의 데이터**를 담당.
- View에서 변경이 발생하면 Controller를 통해 Model이 갱신됨.

#### View
- 사용자 인터페이스 요소(`input`, `checkbox`, `textarea` 등).
- Model을 기반으로 화면을 표시하며, 데이터 자체를 저장하지 않음.
- 변경 시 Controller로 이벤트 전달.

#### Controller
- Model과 View를 연결하는 **중앙 제어 역할**.
- 이벤트 처리 및 로직 담당.
- Model이나 View의 변경을 감지하고 적절한 업데이트 수행.

---

### 3.  MVP 패턴
- MVC에서 **Controller → Presenter**로 변경.
- View와 Presenter가 **1:1 관계**를 가지며, MVC보다 결합이 더 강함.

---

### 4. MVVM 패턴
- **Model - View - ViewModel** 구조.
- ViewModel은 View를 추상화한 계층.
- **Command와 Data Binding**을 통해 양방향 데이터 흐름 지원.
- UI 재사용과 단위 테스트 용이.

---

### 5.  싱글톤 (Singleton)
- 하나의 클래스에 **하나의 인스턴스만 존재**하도록 하는 패턴.

#### 장점
- 인스턴스를 공유해 **메모리 절약 및 효율적 관리** 가능.

#### 단점
- 모듈 간 **의존성이 높아짐**.

#### 개선: 의존성 주입 (Dependency Injection)
- 모듈 교체가 용이하고 테스트 및 마이그레이션이 쉬움.
- 단점: 클래스 수 증가로 복잡성 및 런타임 증가 가능.

---

### 6. 팩토리 (Factory)
- 객체 생성 로직을 **사용 코드에서 분리하여 추상화**하는 패턴.
- 상위 클래스는 뼈대를, 하위 클래스는 **객체 생성 구체 로직**을 담당.

#### 장점
- **느슨한 결합**, 리팩터링 용이.

---

### 7. 전략 패턴 (Strategy / Policy)
- 객체의 행위를 직접 수정하지 않고, **캡슐화된 알고리즘(전략)**을 교체하며 행위를 바꾸는 패턴.
- **상호 교체 가능한 전략**으로 유연성 향상.

---

### 8. 옵저버 (Observer)
- 특정 객체의 상태 변화를 관찰하다가, 변경이 있을 때 **관찰자(옵저버)들에게 알림**을 보내는 패턴.

#### 특징
1. 이벤트 기반 설계.
2. 예: Model 변경 → View 알림 → Controller 동작.
3. JavaScript에서는 `Proxy` 기반으로 구현 가능.

---

### 9. 이터레이터 패턴 (Iterator)
- **Iterator 인터페이스**를 사용해 자료형 구조와 관계없이 요소를 순회하는 패턴.

---

### 10. 노출 모듈 패턴 (Revealing Module Pattern)
- **즉시 실행 함수(IIFE)**를 통해 `public` / `private` 접근제어자처럼 사용할 수 있도록 하는 패턴.
- JavaScript 전역 스코프 오염을 방지하고 은닉성 확보.

---

## 프로그래밍 패러다임

### 1. 선언형 프로그래밍 (Declarative Programming)
- **무엇을** 풀어내는지에 집중하는 패러다임.
- “프로그램은 함수로 이루어진 것이다”라는 철학 기반.

### 2. 함수형 프로그래밍 (Functional Programming)
- 선언형 프로그래밍의 한 종류.
- **순수 함수(Pure Function)**와 **고차 함수(Higher-Order Function)**로 구성.
- 블록처럼 함수를 조합하여 로직 구현, **재사용성 향상**.

### 3. 객체지향 프로그래밍 (OOP)
- 객체 간 상호작용으로 프로그램을 구성.
- 데이터와 메서드를 객체로 묶어 구조화.

#### 주요 개념
1. **추상화(Abstraction)**: 복잡한 시스템에서 핵심 개념만 추출.
2. **다형성(Polymorphism)**: 하나의 메서드/클래스가 여러 형태로 동작.
   - **오버로딩(Overloading)**: 매개변수 타입/개수가 다른 동일 이름 메서드.
   - **오버라이딩(Overriding)**: 상위 클래스 메서드를 하위 클래스에서 재정의.
3. **캡슐화(Encapsulation)**: 데이터와 메서드를 묶고 일부를 외부로부터 은닉.
4. **상속(Inheritance)**: 상위 클래스의 특성을 하위 클래스가 이어받고 확장.

### 4. 절차형 프로그래밍 (Procedural Programming)
- 순차적인 **로직의 흐름**을 중심으로 코드 작성.
- 장점: 읽기 쉽고 빠름.
- 단점: **모듈화가 어려워 유지보수 불리**.

---

## 설계 원칙 (SOLID)

| 원칙 | 이름 | 설명 |
|------|------|------|
| **S** | 단일 책임 원칙 (SRP) | 클래스는 하나의 책임만 가져야 함 |
| **O** | 개방-폐쇄 원칙 (OCP) | 기존 코드를 변경하지 않고 확장 가능해야 함 |
| **L** | 리스코프 치환 원칙 (LSP) | 상위 타입을 하위 타입으로 대체해도 프로그램은 정상 동작해야 함 |
| **I** | 인터페이스 분리 원칙 (ISP) | 하나의 큰 인터페이스보다 여러 개의 구체적 인터페이스가 바람직 |
| **D** | 의존 역전 원칙 (DIP) | 구체적인 것보다 **추상화(인터페이스)**에 의존해야 함 |